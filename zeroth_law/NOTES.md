# Development Notes & Decisions

**NOTE MAINTENANCE:** When adding new dated sections, always include a precise timestamp generated by running `date --iso-8601=seconds` in the terminal.

---

## Pre-commit, Ruff Format, and IDE Integration (Recovered Discussion)

**Initial Problem:** The `ruff-format` pre-commit hook was causing commit failures even when it successfully formatted files, because pre-commit halts on *any* file modification by a hook. This created friction, conflicting with Zeroth Law's goal of smooth flow.

**Constraint:** Removing `ruff-format` from pre-commit entirely is not allowed, as it serves as a critical final quality gate for consistent style (Zeroth Law Principle #4).

**Exploration & Reasoning:**

1.  **Comparing `ruff format` and `black`:** The initial thought was whether `black` might handle pre-commit differently. Conclusion: No, the standard `black` hook also causes pre-commit to halt on modification. The issue stems from pre-commit's core design (fail on change), not a specific tool's behavior.
2.  **`ruff check --fix` Behavior:** We previously configured `ruff check --fix` *without* the `--exit-non-zero-on-fix` flag. This allows the *linter* hook to fix many stylistic issues (like trailing whitespace) silently (exit 0) during commit. It only fails the commit if it finds errors it *cannot* fix.
3.  **Why the `ruff check --fix` solution doesn't apply to `ruff-format`:** The `--exit-non-zero-on-fix` flag is specific to linters-with-fixing. Formatters like `ruff-format` don't have an equivalent flag because their primary job *is* modification. Their successful operation inherently triggers pre-commit's halt-on-modification behavior.
4.  **Idea: Benign vs. Significant Formatting:** Could we configure `ruff-format` to only apply "benign" fixes silently? Conclusion: No, `ruff-format` applies all rules comprehensively, and pre-commit doesn't have a mechanism to ignore specific "benign" modifications from a hook.
5.  **Idea: Leverage IDE:** The user suggested shifting the focus from Git hooks to the IDE (Cursor/VS Code).

**Solution: IDE Format-on-Save + Pre-commit Safety Net:**

1.  **Configure Format-on-Save:** Set up the IDE (Cursor/VS Code) with the Ruff extension to automatically run `ruff format` every time a Python file is saved.
    *   Key settings: `editor.formatOnSave: true`, `editor.defaultFormatter: charliermarsh.ruff`.
2.  **Keep `ruff-format` in `pre-commit`:** The `ruff-format` hook remains in `.pre-commit-config.yaml`.
3.  **Workflow Result:**
    *   Developer saves file -> IDE runs `ruff format` -> File is instantly corrected.
    *   Developer runs `git add` -> Already formatted file is staged.
    *   Developer runs `git commit` -> `pre-commit` runs hooks.
    *   `ruff-format` hook runs, sees the file is already correct, makes no changes, exits 0.
    *   Commit proceeds smoothly unless other hooks (like `ruff check --fix` finding unfixable errors, or `mypy`) fail.
    *   The pre-commit hook acts as a crucial *safety net* for cases where Format-on-Save might have been missed, but it's no longer the primary source of formatting *friction*.

**Conclusion:** This approach respects the Zeroth Law constraint of guaranteed formatting (via the pre-commit hook) while significantly improving the developer workflow smoothness by leveraging IDE automation.

## Standardization on Poetry (2025-04-09)

**Decision:** Updated the core framework document (`frameworks/python/ZerothLawAIFramework.py313.md`) to replace `micromamba`/`conda` with `poetry` as the sole mandated environment and dependency manager.

**Rationale:**
*   **Consistency:** Aligns the framework with the project's actual implementation, which already uses `poetry`.
*   **Modern Tooling:** Leverages `poetry`'s integrated dependency resolution, environment management, and build system capabilities.
*   **Simplified Workflow:** Streamlines environment setup and CI compared to the previous `poetry` -> export -> `micromamba` workflow. Removed the need for intermediate `requirements.txt` files and `environment.yml` for the core workflow.

**Impact:**
*   Removed sections and examples related to `micromamba`, `environment.yml`, and `poetry export` from the framework document.
*   Added `poetry`-specific workflow instructions, project structure examples, and CI pipeline examples.
*   Ensures the framework documentation accurately reflects the required development practices for projects adhering to it.

## Git Root vs. Python Project Root Discrepancy (2025-04-09T14:23:46+08:00)

**Discovery:** Troubleshooting `pre-commit` failures (specifically `mypy` not finding `pyproject.toml`) revealed that the Git repository root (`/home/trahloc/code/Misc`) is different from the Python project root where `pyproject.toml` resides (`/home/trahloc/code/Misc/zeroth_law`).

**Problem:** `pre-commit` hooks execute with the Git repository root as their default working directory. Tools run via these hooks (especially using `language: system` or `language: python`) might not automatically find project-specific configuration files (`pyproject.toml`) if they are located in a subdirectory relative to the Git root.

**Solution / Implication:**
*   Hooks needing project configuration must be explicitly told where to find it relative to the Git root.
*   Example: The `mypy` hook was updated to include `args: [--config-file=zeroth_law/pyproject.toml]`.
*   Scripts or tools run by hooks must be aware of this potential discrepancy and handle paths accordingly (e.g., locate `pyproject.toml` by searching upwards or using relative paths carefully).
*   **Zeroth Law Principle:** This highlights the need to avoid assumptions about directory structure and explicitly configure or discover paths required by tooling.

**Future Consideration:** For project *templates* generated by this tool, ensure they function correctly regardless of whether the Git root and project root are the same.

## Mandatory Pre-commit Config Location (2025-04-09T14:33:11+08:00)

**Decision:** As a strict requirement aligned with Zeroth Law principles of co-location and explicit project structure, the `.pre-commit-config.yaml` file **must** reside within the Python project root (the directory containing `pyproject.toml`), not the Git repository root.

**Rationale:**
*   Keeps configuration directly alongside the code it governs.
*   Reduces ambiguity about which configuration applies when invoking `pre-commit` manually or via hooks.
*   Makes the project structure more self-contained.

**Implication:**
*   `pre-commit` commands must now always be invoked using the `--config <project_root>/.pre-commit-config.yaml` flag when run from the Git root (or any directory other than the project root).
*   Hook configurations (`entry`, `args`, `exclude` paths) within the config file must be defined relative to the project root, as that will be the working directory when `pre-commit` uses the specified config file.
*   Build/CI processes must account for this non-standard config location.

## Custom Git Hook for Multi-Project Dispatch (2025-04-09T15:31:15+08:00)

**Requirement:** The automatic `git commit` hook must enforce project-specific `pre-commit` configurations located within project subdirectories (e.g., `zeroth_law/`), even within a multi-project monorepo (like `Misc/`). Standard `pre-commit install` does not support this.

**Decision:** Implement custom Git hook management within the `zeroth_law` tool itself.

**Mechanism:**
1.  **`zeroth_law install-git-hook --git-root <path>` command:**
    *   Generates a custom script implementing the multi-project dispatch logic (see details below).
    *   Installs this script to `<git_root>/.git/hooks/pre-commit`.
    *   Warns the user if a root `.pre-commit-config.yaml` is found, suggesting `restore-git-hooks` if the repo isn't multi-project.
2.  **Generated Hook Script Logic:**
    *   Identifies staged files.
    *   Determines unique project roots containing these files (dirs with `.pre-commit-config.yaml`).
    *   If > 1 project: FAIL (multi-project commit blocked).
    *   If = 1 project: Run `pre-commit run --config <proj>/.pre-commit-config.yaml --files [staged project files]`.
    *   If = 0 projects (root files only): Pass silently (Exit 0).
3.  **`zeroth_law restore-git-hooks --git-root <path>` command:**
    *   Runs `pre-commit install` in the `<git_root>` to overwrite the custom hook with the standard one.
4.  **Configuration Files:**
    *   `Misc/.pre-commit-config.yaml`: Minimal, repo-wide checks (or empty).
    *   `Misc/zeroth_law/.pre-commit-config.yaml`: Project-specific checks (`ruff`, `mypy`, etc.).

**Rationale:** This approach explicitly codifies the required multi-project behavior within the Zeroth Law tooling, providing a robust, albeit custom, solution that aligns with the framework's goals for automated enforcement in complex repository structures.
