# FILE: src/zeroth_law/git_utils.py
"""Utilities for interacting with Git repositories."""

import logging
import subprocess
from pathlib import Path

log = logging.getLogger(__name__)


def get_staged_files(git_root: Path) -> list[Path]:
    """Gets the list of staged files relative to the Git root.

    Uses `git diff --cached --name-only --diff-filter=ACM`.
    Filters for Added, Copied, Modified files.

    Args:
        git_root: The absolute path to the Git repository root.

    Returns:
        A list of relative Path objects for staged files, or an empty list.

    """
    try:
        result = subprocess.run(
            ["git", "diff", "--cached", "--name-only", "--diff-filter=ACM"],
            capture_output=True,
            text=True,
            check=True,
            cwd=git_root,
            errors="ignore",
        )
        # Return paths relative to the git_root
        return [Path(line) for line in result.stdout.strip().splitlines() if line]
    except FileNotFoundError:
        log.error("'git' command not found. Is Git installed and in PATH?")
        return []
    except subprocess.CalledProcessError as e:
        log.error(f"'git diff' failed: {e.stderr.strip()}")
        return []
    except Exception as e:
        log.exception(f"Unexpected error getting staged files from {git_root}: {e}")
        return []


def identify_project_roots_from_files(staged_files: list[Path], git_root: Path) -> set[Path]:
    """Identifies the unique project root directories for a list of staged files.

    A project root is defined as a direct subdirectory of the git_root that
    contains a `.pre-commit-config.yaml` file.

    Args:
        staged_files: A list of file paths relative to the git_root.
        git_root: The absolute path to the Git repository root.

    Returns:
        A set of unique project root directory names (relative Path objects)
        that contain staged files.

    """
    project_dirs = set()
    for file_path in staged_files:
        try:
            # Check if file is within a first-level subdirectory
            if len(file_path.parts) > 1:
                project_dir_name = file_path.parts[0]
                project_dir_path = git_root / project_dir_name

                # Check if this directory is a project root (contains the config)
                if project_dir_path.is_dir() and (project_dir_path / ".pre-commit-config.yaml").is_file():
                    # Store the relative path (just the directory name)
                    project_dirs.add(Path(project_dir_name))
        except IndexError:
            # Should not happen with Path objects, but handle defensively
            log.warning(f"Could not process path components for: {file_path}")
            continue

    return project_dirs


def generate_custom_hook_script() -> str:
    """Generates the content for the custom multi-project pre-commit hook script."""
    # Using a raw string with triple quotes for the shell script content
    # Important: Ensure correct quoting, especially for file paths and commands
    script_content = r"""#!/usr/bin/env bash
# Custom pre-commit hook generated by Zeroth Law Tool
# Purpose: Dispatch pre-commit checks to project-specific configs
#          in a multi-project monorepo.

set -e

echo "[Zeroth Law Hook] Running custom multi-project pre-commit hook..."

# 1. Get list of staged files (Added, Copied, Modified)
# Use plumbing command for reliability
staged_files=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$staged_files" ]; then
    echo "[Zeroth Law Hook] No staged files detected. Skipping checks."
    exit 0
fi

# 2. Determine the Git root
# Use plumbing command for reliability
git_root=$(git rev-parse --show-toplevel)
if [ -z "$git_root" ]; then
    echo "[Zeroth Law Hook] ERROR: Could not determine Git repository root." >&2
    exit 1
fi

# 3. Identify unique project roots containing staged files
# A project root is a direct subdir of git_root containing .pre-commit-config.yaml
declare -A project_roots # Associative array for uniqueness

while IFS= read -r file; do
    # Get the first path component (potential project dir)
    project_dir=$(echo "$file" | cut -d/ -f1)
    # Check if it's a valid directory and contains the config file
    if [ -d "$git_root/$project_dir" ] && [ -f "$git_root/$project_dir/.pre-commit-config.yaml" ]; then
        project_roots["$project_dir"]=1
    fi
done <<< "$staged_files"

num_projects=${#project_roots[@]}

# 4. Execute based on number of projects found
if [ "$num_projects" -gt 1 ]; then
    # Scenario 1: Multi-Project Commit -> FAIL
    echo "[Zeroth Law Hook] ERROR: Commit includes files from multiple projects." >&2
    echo "Projects detected:" >&2
    for proj in "${!project_roots[@]}"; do
        echo "  - $proj" >&2
    done
    echo "Please commit files for each project separately." >&2
    exit 1
elif [ "$num_projects" -eq 1 ]; then
    # Scenario 2: Single-Project Commit -> Run project config
    # Get the single project directory name (array key)
    project_dir="${!project_roots[@]}"
    project_config_path="$git_root/$project_dir/.pre-commit-config.yaml"
    echo "[Zeroth Law Hook] Detected single project commit: $project_dir"
    echo "[Zeroth Law Hook] Running checks using config: $project_dir/.pre-commit-config.yaml"

    # Filter staged files to only those within this project
    project_staged_files=$(echo "$staged_files" | grep "^$project_dir/")

    # Execute pre-commit run for the specific project
    # Important: Run pre-commit from Git root, passing specific files and config
    # Use printf/xargs for safer file list handling
    printf "%s\0" $project_staged_files | xargs -0 pre-commit run --config "$project_config_path" --files
    exit $? # Exit with the exit code of pre-commit run
else
    # Scenario 3: Root-Only or No-Project Commit -> Pass silently
    echo "[Zeroth Law Hook] No project-specific changes detected. Passing."
    exit 0
fi

"""
    return script_content.strip()


# Add other utility functions here
