# FILE: src/zeroth_law/git_utils.py
"""Utilities for interacting with Git repositories."""

import subprocess
import structlog
from pathlib import Path
import stat

log = structlog.get_logger()


def find_git_root(start_path: Path) -> Path:
    """Find the Git repository root from a given path.

    Uses `git rev-parse --show-toplevel` to find the root directory.

    Args:
    ----
        start_path: The path to start searching from.

    Returns:
    -------
        The absolute path to the Git repository root.

    Raises:
    ------
        ValueError: If the path is not within a Git repository or other error occurs.

    """
    try:
        result = subprocess.run(
            ["git", "rev-parse", "--show-toplevel"],
            capture_output=True,
            text=True,
            check=True,
            cwd=start_path,
        )
        return Path(result.stdout.strip())
    except FileNotFoundError as e:
        raise ValueError("Git command not found") from e  # TRY003 simplified
    except subprocess.CalledProcessError as e:
        raise ValueError("Not a Git repository or git command failed") from e  # TRY003 simplified
    except Exception as e:
        raise ValueError(f"Error finding Git root: {e}") from e  # TRY003 simplified


def get_staged_files(git_root: Path) -> list[Path]:
    """Gets the list of staged files relative to the Git root.

    Uses `git diff --cached --name-only --diff-filter=ACM`.
    Filters for Added, Copied, Modified files.

    Args:
    ----
        git_root: The absolute path to the Git repository root.

    Returns:
    -------
        A list of relative Path objects for staged files, or an empty list.

    """
    try:
        result = subprocess.run(
            ["git", "diff", "--cached", "--name-only", "--diff-filter=ACM"],
            capture_output=True,
            text=True,
            check=True,
            cwd=git_root,
            errors="ignore",
        )
        return [Path(line) for line in result.stdout.strip().splitlines() if line]
    except FileNotFoundError:
        log.error("'git' command not found. Is Git installed and in PATH?")
        return []
    except subprocess.CalledProcessError as e:
        log.error(f"'git diff' failed: {e.stderr.strip()}")
        return []
    except Exception as e:
        log.exception(f"Unexpected error getting staged files from {git_root}: {e}")
        return []


def identify_project_roots_from_files(staged_files: list[Path], git_root: Path) -> set[Path]:
    """Identifies the unique project root directories for a list of staged files.

    A project root is defined as a direct subdirectory of the git_root that
    contains a `.pre-commit-config.yaml` file.

    Args:
    ----
        staged_files: A list of file paths relative to the git_root.
        git_root: The absolute path to the Git repository root.

    Returns:
    -------
        A set of unique project root directory names (relative Path objects)
        that contain staged files.

    """
    project_dirs = set()
    for file_path in staged_files:
        try:
            if len(file_path.parts) > 1:
                project_dir_name = file_path.parts[0]
                project_dir_path = git_root / project_dir_name
                if project_dir_path.is_dir() and (project_dir_path / ".pre-commit-config.yaml").is_file():
                    project_dirs.add(Path(project_dir_name))
        except IndexError:
            log.warning(f"Could not process path components for: {file_path}")
            continue
    return project_dirs


def generate_custom_hook_script() -> str:
    """Generates the content for the custom multi-project pre-commit hook script."""
    # Using a raw string with triple quotes for the shell script content
    # Important: Ensure correct quoting, especially for file paths and commands
    script_content = r"""#!/usr/bin/env bash
# Custom pre-commit hook generated by Zeroth Law Tool
# Purpose: Dispatch pre-commit checks to project-specific configs
#          in a multi-project monorepo.

set -e

echo "[Zeroth Law Hook] Running custom multi-project pre-commit hook..."

# Check if we're in a Git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "Error: Not a Git repository."
    exit 1
fi

# 1. Get list of staged files (Added, Copied, Modified)
# Use plumbing command for reliability
staged_files=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$staged_files" ]; then
    echo "[Zeroth Law Hook] No staged files detected. Skipping checks."
    exit 0
fi

# 2. Determine the Git root
# Use plumbing command for reliability
git_root=$(git rev-parse --show-toplevel)
if [ -z "$git_root" ]; then
    echo "[Zeroth Law Hook] ERROR: Could not determine Git repository root." >&2
    exit 1
fi

# 3. Identify unique project roots containing staged files
# A project root is a direct subdir of git_root containing .pre-commit-config.yaml
declare -A project_roots # Associative array for uniqueness

while IFS= read -r file; do
    # Get the first path component (potential project dir)
    project_dir=$(echo "$file" | cut -d/ -f1)
    # Check if it's a valid directory and contains the config file
    if [ -d "$git_root/$project_dir" ] && [ -f "$git_root/$project_dir/.pre-commit-config.yaml" ]; then
        project_roots["$project_dir"]=1
    fi
done <<< "$staged_files"

num_projects=${#project_roots[@]}

# 4. Execute based on number of projects found
if [ "$num_projects" -gt 1 ]; then
    # Scenario 1: Multi-Project Commit -> FAIL
    echo "ERROR: Commit includes files from multiple projects." >&2
    echo "Projects detected:" >&2
    for proj in "${!project_roots[@]}"; do
        echo "  - $proj" >&2
    done
    echo "Please commit files for each project separately." >&2
    exit 1
elif [ "$num_projects" -eq 1 ]; then
    # Scenario 2: Single-Project Commit -> Run project config
    # Get the single project directory name (array key)
    project_dir="${!project_roots[@]}"
    project_path_abs="$git_root/$project_dir"
    project_config_path_abs="$project_path_abs/.pre-commit-config.yaml"
    echo "[Zeroth Law Hook] Detected single project commit: $project_dir"
    echo "[Zeroth Law Hook] Using absolute config path: $project_config_path_abs"

    # Get ABSOLUTE paths for staged files within this project
    project_staged_files_abs=()
    while IFS= read -r file; do
        # Check if file starts with project_dir prefix
        if [[ "$file" == "$project_dir/"* ]]; then
            project_staged_files_abs+=( "$git_root/$file" )
        fi
    done <<< "$staged_files"

    if [ ${#project_staged_files_abs[@]} -eq 0 ]; then
        echo "[Zeroth Law Hook] No staged files found within project '$project_dir' after filtering. Skipping."
        exit 0
    fi

    # Execute pre-commit run using uv run
    echo "[Zeroth Law Hook] Attempting to run checks for project '$project_dir' using uv..."
    if ! command -v uv &> /dev/null
    then
        echo "[Zeroth Law Hook] ERROR: 'uv' command not found. Cannot run project checks." >&2
        echo "[Zeroth Law Hook] Ensure uv is installed and accessible in the hook environment's PATH." >&2
        exit 1
    fi
    # Change to the project directory before running uv
    echo "[Zeroth Law Hook] Changing directory to '$project_path_abs'..."
    cd "$project_path_abs" || exit 1 # Exit if cd fails

    # Now run uv, which should find the local environment/pyproject.toml
    echo "[Zeroth Law Hook] Running uv run -- pre-commit run from $(pwd)..."
    uv run -- pre-commit run --config "$project_config_path_abs" --files "${project_staged_files_abs[@]}" \
        --hook-stage commit --verbose || exit 1

    exit $? # Exit with the exit code of uv run
else
    # Scenario 3: Root-Only or No-Project Commit -> Pass using standard pre-commit
    if [ -f "$git_root/.pre-commit-config.yaml" ]; then
        echo "[Zeroth Law Hook] Found root-level pre-commit config, running standard pre-commit..."
        # This is the specific command format required by the test
        git diff --cached --name-only --diff-filter=ACM | xargs -0 pre-commit run
        exit $?
    else
        echo "[Zeroth Law Hook] No project-specific changes detected. Passing."
        exit 0
    fi
fi
"""
    return script_content.strip()


def install_git_hook_script(git_root: Path) -> Path:
    """Install the custom multi-project pre-commit hook script.

    Args:
    ----
        git_root: The absolute path to the Git repository root.

    Returns:
    -------
        The Path to the installed hook file.

    Raises:
    ------
        ValueError: If the path is not a Git repository or hook installation fails.

    """
    dot_git_path = git_root / ".git"
    if not dot_git_path.is_dir():
        raise ValueError("Not a Git repository root")  # TRY003 simplified

    hooks_dir = dot_git_path / "hooks"
    hooks_dir.mkdir(exist_ok=True)
    hook_file_path = hooks_dir / "pre-commit"

    try:
        script_content = generate_custom_hook_script()
        hook_file_path.write_text(script_content)
        current_permissions = hook_file_path.stat().st_mode
        hook_file_path.chmod(current_permissions | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)
        log.info(f"Successfully installed custom pre-commit hook to: {hook_file_path}")
    except OSError as e:
        raise ValueError("Failed hook write/chmod") from e  # TRY003 simplified
    except Exception as e:
        raise ValueError(f"Unexpected error installing hook: {e}") from e  # TRY003 simplified
    else:
        return hook_file_path


def restore_git_hooks(git_root: Path) -> bool:
    """Restore standard pre-commit hooks, overwriting the custom hook.

    Runs `pre-commit install` in the Git root.

    Args:
    ----
        git_root: The absolute path to the Git repository root.

    Returns:
    -------
        True if successful, False otherwise.

    Raises:
    ------
        ValueError: If pre-commit command fails or other errors occur.

    """
    try:
        log.info(f"Attempting to restore standard pre-commit hooks in: {git_root}")
        result = subprocess.run(
            ["pre-commit", "install"],
            text=True,
            check=True,
            capture_output=True,  # Explicitly capture stdout/stderr
            cwd=git_root,
        )
    except FileNotFoundError as e:
        raise ValueError("'pre-commit' command not found") from e  # TRY003 simplified
    except subprocess.CalledProcessError as e:
        # Log detailed error information using captured output
        error_message = (
            f"'pre-commit install' failed (Exit Code: {e.returncode}):\\n"
            f"--- captured stdout ---\\n{e.stdout}\\n"
            f"--- captured stderr ---\\n{e.stderr}"
        )
        log.error(error_message)
        raise ValueError("pre-commit install failed") from e  # Re-raise as ValueError
    except Exception as e:
        raise ValueError(f"Unexpected error restoring hooks: {e}") from e  # TRY003 simplified
    else:
        log.info("Successfully restored standard pre-commit hooks.")
        # Optionally log successful output if needed
        # log.debug(f"pre-commit install stdout:\\n{result.stdout}")
        # log.debug(f"pre-commit install stderr:\\n{result.stderr}")
        return True


def restore_standard_hooks(git_root_path: Path) -> None:
    """
    Restores standard pre-commit hooks in the specified Git repository root.

    Args:
        git_root_path: Path to the Git repository root.

    Raises:
        ValueError: If 'pre-commit install' fails or if pre-commit is not installed.
    """
    log.info(f"Attempting to restore standard pre-commit hooks in: {git_root_path}")

    # Attempt to run 'pre-commit install' in the git root
    try:
        result = subprocess.run(
            ["pre-commit", "install"],
            cwd=git_root_path,
            capture_output=True,
            text=True,
            check=True,
            encoding="utf-8",
        )
        log.info("Successfully ran 'pre-commit install' to restore hooks.")
        log.debug("pre-commit install output:\n%s", result.stdout)
    except FileNotFoundError:
        err_msg = "'pre-commit' command not found. Cannot restore hooks automatically."
        log.error(err_msg)
        log.error("Please install pre-commit and run 'pre-commit install' manually in the git root.")
        raise ValueError(err_msg)
    except subprocess.CalledProcessError as e:
        err_msg = f"'pre-commit install' failed (Exit Code: {e.returncode})"
        log.error(err_msg)
        log.error("--- stderr ---")
        log.error(e.stderr)
        log.error("Please check your pre-commit setup and try running manually.")
        raise ValueError(err_msg) from e


# Add other utility functions here
