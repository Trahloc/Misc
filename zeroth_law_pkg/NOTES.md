# Development Notes & Decisions

**NOTE MAINTENANCE:** When adding new dated sections, always include a precise timestamp generated by running `date --iso-8601=seconds` in the terminal.

---

## Pre-commit, Ruff Format, and IDE Integration (Recovered Discussion)

**Initial Problem:** The `ruff-format` pre-commit hook was causing commit failures even when it successfully formatted files, because pre-commit halts on *any* file modification by a hook. This created friction, conflicting with Zeroth Law's goal of smooth flow.

**Constraint:** Removing `ruff-format` from pre-commit entirely is not allowed, as it serves as a critical final quality gate for consistent style (Zeroth Law Principle #4).

**Exploration & Reasoning:**

1.  **Comparing `ruff format` and `black`:** The initial thought was whether `black` might handle pre-commit differently. Conclusion: No, the standard `black` hook also causes pre-commit to halt on modification. The issue stems from pre-commit's core design (fail on change), not a specific tool's behavior.
2.  **`ruff check --fix` Behavior:** We previously configured `ruff check --fix` *without* the `--exit-non-zero-on-fix` flag. This allows the *linter* hook to fix many stylistic issues (like trailing whitespace) silently (exit 0) during commit. It only fails the commit if it finds errors it *cannot* fix.
3.  **Why the `ruff check --fix` solution doesn't apply to `ruff-format`:** The `--exit-non-zero-on-fix` flag is specific to linters-with-fixing. Formatters like `ruff-format` don't have an equivalent flag because their primary job *is* modification. Their successful operation inherently triggers pre-commit's halt-on-modification behavior.
4.  **Idea: Benign vs. Significant Formatting:** Could we configure `ruff-format` to only apply "benign" fixes silently? Conclusion: No, `ruff-format` applies all rules comprehensively, and pre-commit doesn't have a mechanism to ignore specific "benign" modifications from a hook.
5.  **Idea: Leverage IDE:** The user suggested shifting the focus from Git hooks to the IDE (Cursor/VS Code).

**Solution: IDE Format-on-Save + Pre-commit Safety Net:**

1.  **Configure Format-on-Save:** Set up the IDE (Cursor/VS Code) with the Ruff extension to automatically run `ruff format` every time a Python file is saved.
    *   Key settings: `editor.formatOnSave: true`, `editor.defaultFormatter: charliermarsh.ruff`.
2.  **Keep `ruff-format` in `pre-commit`:** The `ruff-format` hook remains in `.pre-commit-config.yaml`.
3.  **Workflow Result:**
    *   Developer saves file -> IDE runs `ruff format` -> File is instantly corrected.
    *   Developer runs `git add` -> Already formatted file is staged.
    *   Developer runs `git commit` -> `pre-commit` runs hooks.
    *   `ruff-format` hook runs, sees the file is already correct, makes no changes, exits 0.
    *   Commit proceeds smoothly unless other hooks (like `ruff check --fix` finding unfixable errors, or `mypy`) fail.
    *   The pre-commit hook acts as a crucial *safety net* for cases where Format-on-Save might have been missed, but it's no longer the primary source of formatting *friction*.

**Conclusion:** This approach respects the Zeroth Law constraint of guaranteed formatting (via the pre-commit hook) while significantly improving the developer workflow smoothness by leveraging IDE automation.

## Standardization on Poetry (2025-04-09)

**Decision:** Updated the core framework document (`frameworks/python/ZerothLawAIFramework.py313.md`) to replace `micromamba`/`conda` with `poetry` as the sole mandated environment and dependency manager.

**Rationale:**
*   **Consistency:** Aligns the framework with the project's actual implementation, which already uses `poetry`.
*   **Modern Tooling:** Leverages `poetry`'s integrated dependency resolution, environment management, and build system capabilities.
*   **Simplified Workflow:** Streamlines environment setup and CI compared to the previous `poetry` -> export -> `micromamba` workflow. Removed the need for intermediate `requirements.txt` files and `environment.yml` for the core workflow.

**Impact:**
*   Removed sections and examples related to `micromamba`, `environment.yml`, and `poetry export` from the framework document.
*   Added `poetry`-specific workflow instructions, project structure examples, and CI pipeline examples.
*   Ensures the framework documentation accurately reflects the required development practices for projects adhering to it.

## Git Root vs. Python Project Root Discrepancy (2025-04-09T14:23:46+08:00)

**Discovery:** Troubleshooting `pre-commit` failures (specifically `mypy` not finding `pyproject.toml`) revealed that the Git repository root (`/home/trahloc/code/Misc`) is different from the Python project root where `pyproject.toml` resides (`/home/trahloc/code/Misc/zeroth_law`).

**Problem:** `pre-commit` hooks execute with the Git repository root as their default working directory. Tools run via these hooks (especially using `language: system` or `language: python`) might not automatically find project-specific configuration files (`pyproject.toml`) if they are located in a subdirectory relative to the Git root.

**Solution / Implication:**
*   Hooks needing project configuration must be explicitly told where to find it relative to the Git root.
*   Example: The `mypy` hook was updated to include `args: [--config-file=zeroth_law/pyproject.toml]`.
*   Scripts or tools run by hooks must be aware of this potential discrepancy and handle paths accordingly (e.g., locate `pyproject.toml` by searching upwards or using relative paths carefully).
*   **Zeroth Law Principle:** This highlights the need to avoid assumptions about directory structure and explicitly configure or discover paths required by tooling.

**Future Consideration:** For project *templates* generated by this tool, ensure they function correctly regardless of whether the Git root and project root are the same.

## Mandatory Pre-commit Config Location (2025-04-09T14:33:11+08:00)

**Decision:** As a strict requirement aligned with Zeroth Law principles of co-location and explicit project structure, the `.pre-commit-config.yaml` file **must** reside within the Python project root (the directory containing `pyproject.toml`), not the Git repository root.

**Rationale:**
*   Keeps configuration directly alongside the code it governs.
*   Reduces ambiguity about which configuration applies when invoking `pre-commit` manually or via hooks.
*   Makes the project structure more self-contained.

**Implication:**
*   `pre-commit` commands must now always be invoked using the `--config <project_root>/.pre-commit-config.yaml` flag when run from the Git root (or any directory other than the project root).
*   Hook configurations (`entry`, `args`, `exclude` paths) within the config file must be defined relative to the project root, as that will be the working directory when `pre-commit` uses the specified config file.
*   Build/CI processes must account for this non-standard config location.

## Custom Git Hook for Multi-Project Dispatch (2025-04-09T15:31:15+08:00)

**Requirement:** The automatic `git commit` hook must enforce project-specific `pre-commit` configurations located within project subdirectories (e.g., `zeroth_law/`), even within a multi-project monorepo (like `Misc/`). Standard `pre-commit install` does not support this.

**Decision:** Implement custom Git hook management within the `zeroth_law` tool itself.

**Mechanism:**
1.  **`zeroth_law install-git-hook --git-root <path>` command:**
    *   Generates a custom script implementing the multi-project dispatch logic (see details below).
    *   Installs this script to `<git_root>/.git/hooks/pre-commit`.
    *   Warns the user if a root `.pre-commit-config.yaml` is found, suggesting `restore-git-hooks` if the repo isn't multi-project.
2.  **Generated Hook Script Logic:**
    *   Identifies staged files.
    *   Determines unique project roots containing these files (dirs with `.pre-commit-config.yaml`).
    *   If > 1 project: FAIL (multi-project commit blocked).
    *   If = 1 project: Run `pre-commit run --config <proj>/.pre-commit-config.yaml --files [staged project files]`.
    *   If = 0 projects (root files only): Pass silently (Exit 0).
3.  **`zeroth_law restore-git-hooks --git-root <path>` command:**
    *   Runs `pre-commit install` in the `<git_root>` to overwrite the custom hook with the standard one.
4.  **Configuration Files:**
    *   `Misc/.pre-commit-config.yaml`: Minimal, repo-wide checks (or empty).
    *   `Misc/zeroth_law/.pre-commit-config.yaml`: Project-specific checks (`ruff`, `mypy`, etc.).

**Rationale:** This approach explicitly codifies the required multi-project behavior within the Zeroth Law tooling, providing a robust, albeit custom, solution that aligns with the framework's goals for automated enforcement in complex repository structures.

## Vision: ZLT as Central Orchestrator for ZLF Enforcement (YYYY-MM-DDTHH:MM:SS+ZZ:ZZ)

**Decision:** Solidified the long-term vision for the Zeroth Law Tool (ZLT). ZLT is intended to be the **single, programmatic enforcer** of the Zeroth Law Framework (ZLF) principles. It will achieve this by directly orchestrating the execution of specialized "consultant" tools (`ruff`, `mypy`, `pytest`, `pylint R0801`, fuzzers like `Atheris`, etc.) based on ZLF rules and project-specific configuration (primarily `pyproject.toml`).

**Rationale:**
*   **Programmatic Ground Truth:** Provides a deterministic, tool-based assessment of ZLF compliance, minimizing ambiguity and reliance on varying AI interpretations for core checks.
*   **Unified Interface:** Developers (AI or human) interact primarily with `zlt validate` for comprehensive feedback.
*   **Consistent Enforcement:** Ensures checks are run uniformly according to ZLF across different environments (local, CI).
*   **Simplified Workflow:** Reduces the need to manage and invoke numerous separate tools manually or via complex hook/CI configurations *once ZLT is mature*.

**Implications for ZLT Development:**
*   Requires significant ZLT development to implement robust execution wrappers for each consultant tool.
*   Needs a well-defined configuration schema (`pyproject.toml`) for ZLT to manage tool execution parameters (paths, flags, timeouts, targets).
*   Requires logic within ZLT to interpret the exit codes and output of each consultant tool in the context of ZLF.
*   Demands a unified reporting system to present aggregated compliance results.

**Current State vs. Future:** This remains the *aspirational architecture*. Currently, ZLT performs some checks directly and may aggregate others, but full orchestration requires substantial development. Near-term workflows will still involve direct tool usage and ZLT's current, more limited capabilities. The ZLF document (`ZerothLawAIFramework.py313.md`) has been updated to reflect this *target* state.

## Refined ZLT Vision: Broad Consultation & Evidence-Based Optimization (YYYY-MM-DDTHH:MM:SS+ZZ:ZZ)

**Decision:** Further refined the ZLT vision based on discussions prioritizing maximum violation detection over minimal configuration. ZLT will aim to run a broader set of checks from consultant tools by default, handle aggregation internally, and use a separate `ZLT-dev` process for long-term, evidence-based optimization.

**Strategy Details:**
1.  **Broad Default Checks:** ZLT, when executing consultant tools like `pylint`, will use a configuration that enables a wide range of checks by default. Only rules known to directly conflict with preferred tools (like `ruff` for style) or that are trivially redundant will be explicitly blacklisted initially.
2.  **ZLT Handles Aggregation:** A core ZLT task is to gather all violations reported by the various consultants and then aggregate/de-duplicate them. It needs to normalize similar violation types reported by different tools and present a unified list of unique ZLF violations found.
3.  **`ZLT-dev` for Optimization:** A separate development/testing process (`ZLT-dev`) will be created. Its role is to:
    *   Harvest real-world test cases (starting with ZLT's own tests).
    *   Run unrestricted consultant tools against these tests.
    *   Build and maintain a capability map (likely in an SQLite DB) tracking which tool rules detect which ZLF violations in the known samples, highlighting unique vs. overlapping detections.
    *   Periodically use insights from this map to provide *evidence-based recommendations* for potentially optimizing ZLT's *default* active rule configurations (e.g., disabling a `pylint` rule if the map consistently shows `ruff` provides equal or better detection across all known samples).

**Rationale:**
*   **Prioritizes Detection:** Reduces the risk of "false negatives" (missed violations) compared to a strict initial whitelist approach.
*   **Manages Complexity Internally:** Shifts the burden of handling tool overlap and result correlation onto ZLT, simplifying the experience for the end-user/AI developer.
*   **Evidence-Based Optimization:** Avoids premature optimization or assumption-based configuration. Changes to the default active ruleset are driven by data gathered over time by `ZLT-dev`.
*   **Continuous Evolution:** Creates a mechanism for ZLT's configuration strategy to adapt as consultant tools evolve.

**Impact:**
*   Increases the initial implementation complexity for ZLT (aggregation logic).
*   Requires development of the `ZLT-dev` process and capability mapping database.
*   Leads to a potentially more robust detection mechanism in the near term and an adaptable, evidence-based configuration in the long term.
*   `TODO.md` and `ZerothLawAIFramework.py313.md` have been updated to reflect this strategy.

### 4.14 Input Robustness Verification (via Fuzz Testing)
*(Supports Principle #14)*

*   **Purpose:** To ensure modules handling complex or untrusted data are resilient against unexpected, malformed, or potentially malicious inputs that might not be covered by standard TDD/DDT test cases. Fuzzing acts as a stress test for input processing logic.
*   **Requirement Trigger:** ZLF **requires** fuzz testing for modules that:
    *   Parse complex file formats (e.g., configuration files beyond simple key-value, data serialization formats like custom binary protocols, source code).

## Naming Convention: Project Root vs. Package Directory (YYYY-MM-DDTHH:MM:SS+ZZ:ZZ - AI: Run `date --iso-8601=seconds`)

**Problem:** The common Python convention `project/src/project/` leads to ambiguity and communication issues (especially with AI assistants) when differentiating between the project root directory and the Python package directory.

**Decision:** The ZLF mandates that the project root directory name and the primary Python package directory name (within `src/`) **must not** be identical.

The **recommended and adopted convention** for ZLF projects is:
`project_pkg/src/project/`

*   **Project Root:** `project_pkg` (e.g., `zeroth_law_pkg`)
*   **Package Directory:** `project` (e.g., `zeroth_law`)
*   **Imports:** Remain clean (e.g., `from zeroth_law import cli`)

**Rationale:**
*   Provides clear, unambiguous distinction between the containing project directory (`_pkg` suffix) and the importable Python package.
*   Prioritizes a clean, standard import name (`project`), which is used frequently in code and expected by tooling.
*   The suffixed root name (`project_pkg`) is explicit for configuration and navigation.
*   Avoids platform-specific issues (like case sensitivity) and uses standard characters.

**Impact:**
*   Requires renaming existing project root directories (e.g., `zeroth_law` -> `zeroth_law_pkg`).
*   Tooling configurations (like `pyproject.toml`) need to be aware that the package `project` resides in `src/` within the `project_pkg` root.
*   The ZLF document (`frameworks/python/ZerothLawAIFramework.py313.md`) has been updated to reflect this mandate and recommendation in Section 6.3.

## Pre-Commit Hook Environment Issue for MyPy in Monorepo (2025-04-11T01:06:32+08:00)

**Problem:** When running `mypy` via the project-specific `.pre-commit-config.yaml` (invoked by the custom multi-project dispatcher hook in the Git root), the execution environment set up by `pre-commit` caused persistent failures in `mypy`'s module path resolution for the `src`-layout (`src/zeroth_law/`). This occurred despite the dispatcher script successfully changing the working directory to the project root (`zeroth_law_pkg/`). Manifestations included recurring `"Source file found twice"` errors or failures to find `pyproject.toml` or source directories, depending on the specific hook configuration (`language: python` vs `language: system`, different `entry` commands). This indicates an issue with how the hook execution environment (paths, CWD inheritance, command resolution) interacts with `mypy` in this monorepo setup, rather than a fundamental `mypy` bug or configuration error in `pyproject.toml`.

**Failed Attempts (Illustrating Environment Issues):**
*   Using `language: python` with various `args`: Could not reliably resolve paths relative to the CWD set by the dispatcher, often hitting "Source file found twice" or "Cannot find file" errors.
*   Using `language: system` with `entry: poetry run mypy .`: Failed because the nested `poetry run` appeared to lose the CWD context set by the dispatcher.
*   Using `language: system` with `entry: mypy .` (with or without `--config-file`): Failed because `mypy` appeared to execute relative to the original Git root CWD, not the one set by the dispatcher.
*   Using `language: system` with `entry: sh -c 'cd zeroth_law_pkg && mypy . --config-file ./pyproject.toml'`: *Still* failed with "Source file found twice", indicating the subshell environment was also inheriting problematic path resolution or command execution context.
*   Standard `mypy` config adjustments in `pyproject.toml` (`mypy_path`, `explicit-package-bases`, `ignore_errors`) and environment variables (`MYPYPATH`) were ineffective against the hook execution environment issue.

**Working Solution (Hook Execution Workaround):**
The only configuration found to reliably execute `mypy` correctly *within the hook context* involves forcing a specific execution sequence using `language: system`:

```yaml
# In zeroth_law_pkg/.pre-commit-config.yaml
-   repo: local
    hooks:
      - id: mypy
        name: mypy (local project)
        language: system
        # The initial 'echo' appears necessary to establish a stable/correct
        # execution environment for the subsequent 'sh -c' command within the
        # pre-commit + language: system context on this specific setup.
        # It seems to allow 'sh' and its subsequent commands ('cd', 'mypy')
        # to resolve correctly relative to PATH and the CWD.
        entry: echo "Running mypy in zeroth_law_pkg" && sh -c 'cd zeroth_law_pkg && mypy . --config-file ./pyproject.toml'
        pass_filenames: false
        args: []
```

**Rationale for Workaround:** Adding the `echo` *before* the `sh -c '...'` command seems to influence the hook execution environment provided by `pre-commit` when using `language: system`. This allows the subsequent subshell (`sh -c`) to correctly resolve `sh`, `cd`, and `mypy` relative to the PATH and the CWD set by the dispatcher (`zeroth_law_pkg`). Without the preceding `echo`, the environment appeared inconsistent, potentially misinterpreting command paths or CWD. This workaround specifically addresses the hook execution environment quirk encountered in this setup.
