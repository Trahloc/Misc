# FILE: tests/test_tool_defs/test_ensure_json_definitions_exist.py
"""
Tests that a high-trust JSON definition file exists for every managed
tool/subcommand defined in managed_tools.yaml.

This test DOES NOT generate missing JSON files. It relies on a separate
process (likely AI-driven) to create the JSON based on the corresponding
ground-truth TXT file.
"""

import pytest
import logging  # Import logging
from pathlib import Path  # Import Path

# Reuse helpers from the TXT baseline test for consistency
# Ensure MANAGED_COMMAND_SEQUENCES is correctly populated before this import
from .test_ensure_txt_baselines_exist import MANAGED_COMMAND_SEQUENCES, command_sequence_to_id


# Setup logger for this test module
log = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)  # Configure as needed

# --- Constants ---
# No constants needed here now


# --- Test Function ---
@pytest.mark.parametrize(
    "command_parts",
    MANAGED_COMMAND_SEQUENCES,
    # Correctly call the id function for each parameter
    ids=[command_sequence_to_id(cp) for cp in MANAGED_COMMAND_SEQUENCES],
)
# Add WORKSPACE_ROOT and TOOLS_DIR as arguments from conftest
def test_json_definition_exists(command_parts: tuple[str, ...], tool_index_handler, WORKSPACE_ROOT, TOOLS_DIR):
    """
    Verifies that the JSON definition file exists for a given managed
    command sequence. Fails if the file is missing.
    Relies on the files being populated/generated by a separate process.
    Requires WORKSPACE_ROOT and TOOLS_DIR from conftest.
    """
    if not command_parts:
        pytest.skip("Skipping test for empty command parts.")

    tool_id = command_sequence_to_id(command_parts)
    tool_name = command_parts[0]

    # Use dynamically provided paths
    tool_dir = TOOLS_DIR / tool_name
    json_file = tool_dir / f"{tool_id}.json"
    relative_json_path = json_file.relative_to(WORKSPACE_ROOT)
    # Define txt file path - directly in tool_dir
    txt_file = tool_dir / f"{tool_id}.txt"
    relative_txt_path = txt_file.relative_to(WORKSPACE_ROOT)

    # --- Perform the actual test checks ---

    # Check directory structure first
    assert tool_dir.is_dir(), (
        f"Base tool directory missing for '{tool_id}'. Expected at: {tool_dir}\n"
        f"Action Required: Ensure the directory structure is correct or the tool population process created it."
    )

    # Check JSON file existence
    assert json_file.is_file(), (
        f"JSON definition file missing: {relative_json_path}\n"
        f"Action Required: Ensure the JSON file for '{tool_id}' has been generated/populated."
    )

    # Add a log message for success
    log.info(f"Checks passed for existing JSON for: {tool_id}")
