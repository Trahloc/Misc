# FILE: tests/test_tool_defs/test_ensure_json_definitions_exist.py
"""
Tests that a high-trust JSON definition file exists for every managed
tool/subcommand defined in managed_tools.yaml.

This test DOES NOT generate missing JSON files. It relies on a separate
process (likely AI-driven) to create the JSON based on the corresponding
ground-truth TXT file.
"""

import pytest
import logging  # Import logging

# Need these core paths as well
from zeroth_law.dev_scripts.tool_discovery import (
    TOOLS_DIR,
    WORKSPACE_ROOT,
)

# Reuse helpers from the TXT baseline test for consistency
from .test_ensure_txt_baselines_exist import MANAGED_COMMAND_SEQUENCES, command_sequence_to_id


# Setup logger for this test module
log = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)  # Configure as needed

# --- Constants ---
# JSON_DIR_NAME = "json" # REMOVED

# --- Fixture for Cleanup ---
# @pytest.fixture
# def clean_tool_def_files(request):
#    ...


# --- Test Function ---
# Remove indirect parametrization and the fixture from the parameters
@pytest.mark.parametrize(
    "command_parts",
    MANAGED_COMMAND_SEQUENCES,
    ids=command_sequence_to_id,
)
def test_json_definition_exists(command_parts: tuple[str, ...], tool_index_handler):  # Removed clean_tool_def_files param
    """
    Verifies that the JSON definition file exists for a given managed
    command sequence. Fails if the file is missing.
    Relies on the files being populated/generated by a separate process.
    """
    # --- DEBUGGING --- END

    # Fixture no longer runs here

    if not command_parts:
        pytest.skip("Skipping test for empty command parts.")

    tool_id = command_sequence_to_id(command_parts)
    tool_name = command_parts[0]

    tool_dir = TOOLS_DIR / tool_name
    json_file = tool_dir / f"{tool_id}.json"
    relative_json_path = json_file.relative_to(WORKSPACE_ROOT)
    relative_txt_path = (tool_dir / f"{tool_id}.txt").relative_to(WORKSPACE_ROOT)

    # --- REMOVE Simulate Baseline Generation Block --- START
    # command_str = " ".join(command_parts)
    # print(f"\nSimulating baseline generation for {command_str} within test setup...")
    # try:
    #    ...
    # except Exception as e:
    #     pytest.fail(f"Exception during baseline generation simulation for '{command_str}': {e}")
    # --- REMOVE Simulate Baseline Generation Block --- END

    # --- Perform the actual test checks ---

    # Check directory structure first
    # We assert tool_dir exists because the population process should ensure it.
    assert tool_dir.is_dir(), (
        f"Base tool directory missing for '{tool_id}'. Expected at: {tool_dir}\n"
        f"Action Required: Ensure the directory structure is correct or the tool population process created it."
    )

    # Check JSON file existence
    assert json_file.is_file(), (
        f"JSON definition file missing: {relative_json_path}\n"
        f"Action Required: Ensure the JSON file for '{tool_id}' has been generated/populated."
    )

    # Add a log message for success
    log.info(f"Checks passed for existing JSON for: {tool_id}")
