# FILE: tests/test_tool_defs/test_ensure_json_definitions_exist.py
"""
Tests that a high-trust JSON definition file exists for every managed
tool/subcommand defined in managed_tools.yaml.

This test DOES NOT generate missing JSON files. It relies on a separate
process (likely AI-driven) to create the JSON based on the corresponding
ground-truth TXT file.
"""

import pytest
import logging  # Import logging
from pathlib import Path  # Import Path
import os

# Setup logger for this test module
log = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)  # Configure as needed

# Reuse helpers from the TXT baseline test for consistency
# Ensure MANAGED_COMMAND_SEQUENCES is correctly populated before this import
from .test_ensure_txt_baselines_exist import MANAGED_COMMAND_SEQUENCES, command_sequence_to_id


# --- Constants ---
# No constants needed here now


# --- Test Function ---
@pytest.mark.parametrize(
    "command_parts",
    MANAGED_COMMAND_SEQUENCES,
    # Correctly call the id function for each parameter
    ids=[command_sequence_to_id(cp) for cp in MANAGED_COMMAND_SEQUENCES],
)
# Add WORKSPACE_ROOT and TOOLS_DIR as arguments from conftest
def test_json_definition_exists(command_parts: tuple[str, ...], WORKSPACE_ROOT, TOOLS_DIR):
    """
    Verifies that the JSON definition file exists for a given managed
    command sequence identified by the test setup.
    Relies on the files being populated/generated by a separate process.
    Requires WORKSPACE_ROOT and TOOLS_DIR from conftest.
    """
    if not command_parts:
        pytest.skip("Skipping test for empty command parts.")

    tool_id = command_sequence_to_id(command_parts)
    tool_name = command_parts[0]

    # --- Determine expected paths (Corrected Logic) ---
    # Base tool directory (e.g., .../tools/ruff/)
    base_tool_dir = TOOLS_DIR / tool_name

    # JSON file path (e.g., .../tools/ruff/ruff_analyze.json)
    # Uses the tool_id for the filename, located within the base_tool_dir
    json_file = base_tool_dir / f"{tool_id}.json"
    relative_json_path = json_file.relative_to(WORKSPACE_ROOT)

    # TXT file path (for context in error message, doesn't need to exist for this test)
    txt_file = base_tool_dir / f"{tool_id}.txt"
    relative_txt_path = txt_file.relative_to(WORKSPACE_ROOT)

    # --- Perform the actual test checks ---

    # Check base tool directory existence first
    # This is implicitly covered if the JSON exists within it, but good practice
    assert base_tool_dir.is_dir(), (
        f"Base tool directory missing for managed sequence '{tool_id}'. Expected at: {base_tool_dir}\n"
        f"Action Required: Ensure the directory structure is correct OR "
        f"remove/exclude '{tool_name}' from pyproject.toml whitelist."
    )

    # Check JSON file existence
    assert json_file.is_file(), (
        f"JSON definition file missing for managed sequence '{tool_id}'. Expected at: {relative_json_path}\n"
        f"Action Required: Ensure the JSON file exists (it should be generated from {relative_txt_path} if TXT exists) "
        f"OR remove/exclude '{tool_name}' (and potentially its subcommands like '{tool_id}') from pyproject.toml whitelist."
    )

    # Add a log message for success
    log.info(f"Checks passed for existing JSON for: {tool_id}")


# Added: Decorator to apply the same parameters as the test above
@pytest.mark.parametrize(
    "command_parts",
    MANAGED_COMMAND_SEQUENCES,
    # Correctly call the id function for each parameter
    ids=[command_sequence_to_id(cp) for cp in MANAGED_COMMAND_SEQUENCES],
)
# Ensure WORKSPACE_ROOT and TOOLS_DIR are passed
# Add tool_index_handler fixture
# NOTE: The @pytest.mark.parametrize block is NOT repeated here.
# This definition applies to the SAME set of parameters as test_json_definition_exists
def test_json_definition_parses(command_parts: tuple[str, ...], WORKSPACE_ROOT, TOOLS_DIR, tool_index_handler):
    """
    Verifies that the existing JSON definition file can be parsed correctly.
    This test assumes the JSON file exists, relying on test_json_definition_exists
    to pass first for the same command sequence.
    Requires WORKSPACE_ROOT, TOOLS_DIR from conftest, and tool_index_handler fixture.
    """
    if not command_parts:
        pytest.skip("Skipping test for empty command parts.")

    tool_id = command_sequence_to_id(command_parts)
    tool_name = command_parts[0]

    # --- Determine expected paths ---
    base_tool_dir = TOOLS_DIR / tool_name
    json_file = base_tool_dir / f"{tool_id}.json"
    relative_json_path = json_file.relative_to(WORKSPACE_ROOT)

    # --- Perform the test ---
    # No need to check existence again, assume test_json_definition_exists passed.
    # Get the definition using the handler
    try:
        # Use the handler's method to load and validate the JSON
        definition = tool_index_handler.get_tool_definition(tool_id)
        # --- Updated Check ---
        # Fail immediately if the definition file was missing or invalid
        if definition is None:
            pytest.fail(
                f"ToolIndexHandler failed to load definition for '{tool_id}'. "
                f"Check logs for reasons (file missing? invalid JSON?). "
                f"Expected path: {relative_json_path}"
            )

        # Basic validation of structure (can be expanded)
        assert "metadata" in definition, "Parsed JSON definition is missing 'metadata' key."
        assert "command" in definition, "Parsed JSON definition is missing 'command' key."
        assert "subcommand" in definition, "Parsed JSON definition is missing 'subcommand' key."
        assert "description" in definition, "Parsed JSON definition is missing 'description' key."

        # Check if command and subcommand match the input command_parts
        parsed_command = definition.get("command")
        parsed_subcommand = definition.get("subcommand")  # Could be None

        # Reconstruct the sequence from the parsed definition
        if parsed_subcommand is not None:
            parsed_sequence = (parsed_command, parsed_subcommand)
        else:
            parsed_sequence = (parsed_command,)

        # Compare with the input sequence from parametrize
        assert parsed_sequence == command_parts, (
            f"Command/Subcommand mismatch in JSON for '{tool_id}'. "
            f"Expected sequence from parametrize: {command_parts}, "
            f"Found sequence from JSON: {parsed_sequence} (command='{parsed_command}', subcommand='{parsed_subcommand}')"
        )

        log.info(f"Successfully parsed and validated basic structure for JSON: {tool_id}")

    except FileNotFoundError:
        # This case *shouldn't* happen if test_json_definition_exists passes,
        # but handle defensively.
        pytest.fail(
            f"JSON definition file missing for '{tool_id}' at {relative_json_path}, "
            f"even though test_json_definition_exists should have caught this."
        )
    except Exception as e:
        # Catch JSON parsing errors or other unexpected issues from the handler
        pytest.fail(f"Failed to parse or validate JSON definition for '{tool_id}' at {relative_json_path}. Error: {e}")
