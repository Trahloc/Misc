# FILE: tests/test_tool_defs/test_txt_json_consistency.py
"""
Compares the CRC value in the JSON definition file with the CRC value
stored in the tool_index.json file for each managed sequence.
"""

import json
import pytest
import logging
from pathlib import Path
import warnings
import jsonschema
from typing import List, Tuple, Dict, Any

# Import command_sequence_to_id from the conftest in the same directory
from .conftest import command_sequence_to_id

# Comment out the failing import for now
# from zeroth_law.dev_scripts.consistency_checker import check_crc_consistency, ConsistencyStatus

# Import fixtures from this directory's conftest
# (WORKSPACE_ROOT, TOOLS_DIR, TOOL_INDEX_PATH, tool_index_handler, managed_sequences)
from .conftest import managed_sequences  # Import the fixture

# Assuming refactored consistency checker component exists
# Assuming managed_sequences fixture is available from conftest
# Assuming WORKSPACE_ROOT, TOOL_DEFS_DIR_FIXTURE, TOOL_INDEX_PATH fixtures are available

log = logging.getLogger(__name__)
# logging.basicConfig(level=logging.INFO) # Configure globally or via pytest.ini


# Remove the faulty test function that calls the fixture directly
# --- Test Function (Uses managed_sequences fixture) ---
# @pytest.mark.parametrize(
#     "command_parts",
#     # Use the fixture by passing its name as an argument to the test function
#     # Pytest automatically resolves this based on conftest.py
#     # We need to ensure the fixture itself provides the data for parametrization.
#     # A direct parametrize like this might require the fixture to be calculated
#     # *before* parametrization happens, which is tricky.
#     # Let's restructure to iterate within the test function instead.
#     # managed_sequences,
#     argvalues=[
#         pytest.param(seq, id=command_sequence_to_id(seq)) for seq in managed_sequences([])
#     ],  # Placeholder to get ids
#     # ids=[command_sequence_to_id(cp) for cp in managed_sequences],
# )
# def test_txt_json_consistency(
#     command_parts: tuple[str, ...],
#     managed_sequences: list,  # Add fixture as argument
#     tool_index_handler,  # Existing fixture
#     WORKSPACE_ROOT: Path,  # Existing fixture
#     TOOLS_DIR: Path,  # Existing fixture
#     TOOL_INDEX_PATH: Path,  # Existing fixture
# ):
#     """Compares JSON CRC with index CRC for each managed sequence."""
#
#     # Check if the current command_parts is actually in the generated list
#     # This seems overly complex due to parametrization limitations.
#     # Let's simplify: remove parametrize and iterate within the function.
#     pass  # Remove parametrization structure


def test_all_txt_json_consistency(
    managed_sequences: list,  # Use the fixture
    tool_index_handler,  # Existing fixture
    WORKSPACE_ROOT: Path,  # Existing fixture
    TOOLS_DIR: Path,  # Existing fixture
    TOOL_INDEX_PATH: Path,  # Existing fixture
):
    """Compares JSON CRC with index CRC for all managed sequences."""

    if not managed_sequences:
        pytest.skip("No managed sequences generated by fixture.")

    failures = []
    for command_parts in managed_sequences:
        if not command_parts:
            log.warning("Skipping empty command parts tuple in consistency check.")
            continue

        tool_id = command_sequence_to_id(command_parts)
        tool_name = command_parts[0]
        tool_dir = TOOLS_DIR / tool_name
        json_file = tool_dir / f"{tool_id}.json"
        relative_json_path = json_file.relative_to(WORKSPACE_ROOT)
        relative_txt_path = TOOLS_DIR / tool_name / f"{tool_id}.txt".relative_to(WORKSPACE_ROOT)  # For messages

        # Use the refactored consistency checker
        status, message = check_crc_consistency(command_parts, tool_index_handler, TOOLS_DIR, WORKSPACE_ROOT)

        if status == ConsistencyStatus.JSON_MISSING:
            failures.append(f"{tool_id}: JSON file missing at {relative_json_path}. Cannot perform consistency check.")
        elif status == ConsistencyStatus.JSON_ERROR:
            failures.append(f"{tool_id}: Failed to load/decode JSON file {relative_json_path}: {message}")
        elif status == ConsistencyStatus.INDEX_MISSING:
            failures.append(
                f"{tool_id}: Managed sequence missing a valid CRC entry in the tool index {TOOL_INDEX_PATH.relative_to(WORKSPACE_ROOT)}: {message}"
            )
        elif status == ConsistencyStatus.JSON_CRC_MISSING:
            failures.append(f"{tool_id}: Missing 'metadata.ground_truth_crc' in {relative_json_path}.")
        elif status == ConsistencyStatus.SKELETON_NEEDS_POPULATING:
            # Format message similar to the original test failure for AI instructions
            index_crc, index_source = message  # Unpack details from message
            fail_message = (
                f"{tool_id}: JSON CRC is skeleton value (0x00000000).\n"
                f"  JSON file ({relative_json_path}): metadata.ground_truth_crc = 0x00000000\n"
                f"  Tool Index ({TOOL_INDEX_PATH.relative_to(WORKSPACE_ROOT)}): Expected CRC = {index_crc} (Source: {index_source})\n"
                f"--- MANDATE REINFORCEMENT --- \n"
                f"  Your ONLY task is to populate the STRUCTURE (description, usage, options, arguments, subcommands) based on the ground truth TXT baseline ({relative_txt_path}).\n"
                f"  You MUST NOT manually set the 'metadata.ground_truth_crc' field. This field is managed EXCLUSIVELY by automated tooling.\n"
                f"----------------------------- \n"
                f"Action Required (AI): This JSON file ({relative_json_path}) is a skeleton and needs its structure populated based on the TXT baseline.\n"
                f"  Steps:\n"
                f"  1. Read the ground truth TXT file: {relative_txt_path} (verify via test_ensure_txt_baselines_exist results).\n"
                f"  2. **Populate ONLY the JSON STRUCTURE in this file ({relative_json_path}) based on the TXT content and schema guidelines.**\n"
                f"  3. **After confirming the JSON structure is fully populated and correct**, use the designated CRC update tool (verify script name in project). This tool *must* be used to set the CRC; do not edit it manually.\n"
                f"  4. Ensure the resulting JSON content adheres to the schema (check test_json_schema_validation.py results)."
            )
            failures.append(fail_message)
        elif status == ConsistencyStatus.MISMATCH:
            json_crc, index_crc, index_source = message  # Unpack details
            fail_message = (
                f"{tool_id}: JSON CRC mismatch (case-insensitive comparison).\n"
                f"  JSON file ({relative_json_path}): metadata.ground_truth_crc = {json_crc}\n"
                f"  Tool Index ({TOOL_INDEX_PATH.relative_to(WORKSPACE_ROOT)}): Expected CRC = {index_crc} (Source: {index_source})\n"
                f"--- MANDATE REINFORCEMENT --- \n"
                f"  Your ONLY task related to this file ({relative_json_path}) is to ensure its STRUCTURE (description, usage, options, arguments, subcommands) accurately reflects the ground truth TXT baseline ({relative_txt_path}).\n"
                f"  You MUST NOT manually edit the 'metadata.ground_truth_crc' field. This field is managed EXCLUSIVELY by automated tooling.\n"
                f"----------------------------- \n"
                f"Action Required (AI): The JSON definition's structure needs updating based on its source TXT baseline.\n"
                f"  Steps:\n"
                f"  1. Verify the TXT file ({relative_txt_path}) content is up-to-date (check test_ensure_txt_baselines_exist results).\n"
                f"  2. Read the current content of this JSON file ({relative_json_path}).\n"
                f"  3. **Update ONLY the JSON STRUCTURE based on the verified TXT content.** Ensure the structure is complete and accurate according to the TXT baseline.\n"
                f"  4. **After confirming the JSON structure is correct**, use the designated CRC update tool (verify script name). This tool *must* be used to set the CRC; do not edit it manually.\n"
                f"  5. Ensure the resulting JSON content adheres to the schema (check test_json_schema_validation.py results).\n"
                f"Alternatively, if this sequence ('{tool_id}') should not be managed, update configuration."
            )
            failures.append(fail_message)
        elif status == ConsistencyStatus.OK:
            log.info(f"Consistency check PASSED for {tool_id}.")
        elif status == ConsistencyStatus.SKIPPED_INTENTIONAL_SKELETON:
            log.info(f"Consistency check SKIPPED for {tool_id} (intentional skeleton).")

    if failures:
        pytest.fail("\n\n".join(failures), pytrace=False)
