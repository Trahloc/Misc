# FILE: tests/test_tool_defs/test_txt_json_consistency.py
"""
Compares the CRC value in the JSON definition file with the CRC value
stored in the tool_index.json file for each managed sequence.
"""

import json
import pytest
import logging
from pathlib import Path
import warnings
import jsonschema
from typing import List, Tuple, Dict, Any
import zlib

# Import the helper function from the root conftest
from tests.conftest import command_sequence_to_id, calculate_crc32_hex

# Import command_sequence_to_id from the conftest in the same directory
# from .conftest import command_sequence_to_id # REMOVE THIS - Fixtures/helpers moved to root conftest

# Comment out the failing import for now
# from zeroth_law.dev_scripts.consistency_checker import check_crc_consistency, ConsistencyStatus


# Define status enum locally
class ConsistencyStatus:
    CONSISTENT = 0
    JSON_MISSING = 1
    JSON_ERROR = 2
    INDEX_MISSING = 3
    JSON_CRC_MISSING = 4
    SKELETON_NEEDS_POPULATING = 5
    MISMATCH = 6


# Import fixtures from this directory's conftest
# (WORKSPACE_ROOT, TOOLS_DIR, TOOL_INDEX_PATH, tool_index_handler, managed_sequences)
# from .conftest import managed_sequences  # REMOVE THIS - Fixture now in root conftest

# Assuming refactored consistency checker component exists
# Assuming managed_sequences fixture is available from conftest
# Assuming WORKSPACE_ROOT, TOOL_DEFS_DIR_FIXTURE, TOOL_INDEX_PATH fixtures are available

log = logging.getLogger(__name__)
# logging.basicConfig(level=logging.INFO) # Configure globally or via pytest.ini


# Remove the faulty test function that calls the fixture directly
# --- Test Function (Uses managed_sequences fixture) ---
# @pytest.mark.parametrize(
#     "command_parts",
#     # Use the fixture by passing its name as an argument to the test function
#     # Pytest automatically resolves this based on conftest.py
#     # We need to ensure the fixture itself provides the data for parametrization.
#     # A direct parametrize like this might require the fixture to be calculated
#     # *before* parametrization happens, which is tricky.
#     # Let's restructure to iterate within the test function instead.
#     # managed_sequences,
#     argvalues=[
#         pytest.param(seq, id=command_sequence_to_id(seq)) for seq in managed_sequences([])
#     ],  # Placeholder to get ids
#     # ids=[command_sequence_to_id(cp) for cp in managed_sequences],
# )
# def test_txt_json_consistency(
#     command_parts: tuple[str, ...],
#     managed_sequences: list,  # Add fixture as argument
#     tool_index_handler,  # Existing fixture
#     WORKSPACE_ROOT: Path,  # Existing fixture
#     TOOLS_DIR: Path,  # Existing fixture
#     TOOL_INDEX_PATH: Path,  # Existing fixture
# ):
#     """Compares JSON CRC with index CRC for each managed sequence."""
#
#     # Check if the current command_parts is actually in the generated list
#     # This seems overly complex due to parametrization limitations.
#     # Let's simplify: remove parametrize and iterate within the function.
#     pass  # Remove parametrization structure


def test_all_txt_json_consistency(
    managed_sequences: list,  # Use the fixture
    tool_index_handler,  # Existing fixture
    WORKSPACE_ROOT: Path,  # Existing fixture
    TOOLS_DIR: Path,  # Existing fixture
    TOOL_INDEX_PATH: Path,  # Existing fixture
):
    """Compares JSON CRC with index CRC for all managed sequences."""

    if not managed_sequences:
        pytest.skip("No managed sequences generated by fixture.")

    failures = []
    # Ensure we iterate over elements if it's a set/list, not characters if it's a string
    if isinstance(managed_sequences, str):
        # This case shouldn't happen if the fixture is correct, but handles defensively
        log.warning(f"managed_sequences fixture returned a string, not an iterable of sequences: {managed_sequences}")
        managed_sequences = [managed_sequences]  # Treat it as a single sequence

    for command_sequence in managed_sequences:
        # Handle potential tuple vs string items in the managed_sequences list/set
        if isinstance(command_sequence, str):
            command_parts = (command_sequence,)  # Convert single tool name to tuple
        elif isinstance(command_sequence, tuple):
            command_parts = command_sequence
        else:
            log.warning(
                f"Skipping unexpected item type in managed_sequences: {type(command_sequence)} - {command_sequence}"
            )
            continue

        if not command_parts:
            log.warning("Skipping empty command parts tuple in consistency check.")
            continue

        tool_id = command_sequence_to_id(command_parts)
        tool_name = command_parts[0]
        tool_dir = TOOLS_DIR / tool_name
        json_file = tool_dir / f"{tool_id}.json"
        relative_json_path = json_file.relative_to(WORKSPACE_ROOT)
        # Correctly construct the Path object for the txt file first
        txt_file_path = tool_dir / f"{tool_id}.txt"
        relative_txt_path = txt_file_path.relative_to(WORKSPACE_ROOT)  # Call relative_to on the Path

        # Skip consistency check if the JSON file doesn't exist
        if not json_file.is_file():
            failures.append(f"{tool_id}: JSON file missing at {relative_json_path}. Cannot perform consistency check.")
            continue

        # Use the refactored consistency checker
        # status, message = check_crc_consistency(command_parts, tool_index_handler, TOOLS_DIR, WORKSPACE_ROOT)

        # --- Inlined CRC Consistency Check Logic ---
        status = ConsistencyStatus.CONSISTENT  # Default
        message = None
        json_crc = None
        index_entry = None
        index_crc = None
        index_crc_source = "Unknown"

        try:
            # 1. Get Index Entry using handler's raw data
            raw_index_data = tool_index_handler.get_raw_index_data()
            # index_entry = tool_index_handler.get_entry(command_parts) # Incorrect method
            index_entry = _get_entry_from_raw_index(raw_index_data, command_parts)

            if index_entry is None:
                status = ConsistencyStatus.INDEX_MISSING
                message = "Entry not found in index."
            else:
                index_crc = index_entry.get("crc")
                index_crc_source = index_entry.get("source", "tool_index.json")  # Assuming source is stored
                if index_crc is None:
                    status = ConsistencyStatus.INDEX_MISSING
                    message = "'crc' field missing in index entry."

            # 2. Load JSON and get its CRC (only if index CRC was found)
            if status == ConsistencyStatus.CONSISTENT:
                try:
                    with open(json_file, "r", encoding="utf-8") as f:
                        data = json.load(f)
                    if "metadata" not in data or not isinstance(data["metadata"], dict):
                        status = ConsistencyStatus.JSON_CRC_MISSING
                        message = "'metadata' object missing or invalid."
                    else:
                        json_crc = data["metadata"].get("ground_truth_crc")
                        if json_crc is None:
                            status = ConsistencyStatus.JSON_CRC_MISSING
                            message = "'metadata.ground_truth_crc' field missing."
                except json.JSONDecodeError as e:
                    status = ConsistencyStatus.JSON_ERROR
                    message = str(e)
                except OSError as e:
                    # This case should be caught earlier, but good to handle
                    status = ConsistencyStatus.JSON_MISSING
                    message = str(e)

            # 3. Compare CRCs (only if both were loaded successfully)
            if status == ConsistencyStatus.CONSISTENT:
                if str(json_crc).lower() == "0x00000000":
                    status = ConsistencyStatus.SKELETON_NEEDS_POPULATING
                    message = (index_crc, index_crc_source)  # Pass needed info
                elif str(json_crc).lower() != str(index_crc).lower():
                    status = ConsistencyStatus.MISMATCH
                    message = (json_crc, index_crc, index_crc_source)  # Pass needed info

        except Exception as e:
            # Catch unexpected errors during the check
            log.exception(f"Unexpected error during consistency check for {tool_id}: {e}")
            status = ConsistencyStatus.JSON_ERROR  # Or a generic error status
            message = f"Unexpected error: {e}"
        # --- End Inlined Logic ---

        if status == ConsistencyStatus.JSON_MISSING:
            failures.append(f"{tool_id}: JSON file missing at {relative_json_path}. Cannot perform consistency check.")
        elif status == ConsistencyStatus.JSON_ERROR:
            failures.append(f"{tool_id}: Failed to load/decode JSON file {relative_json_path}: {message}")
        elif status == ConsistencyStatus.INDEX_MISSING:
            failures.append(
                f"{tool_id}: Managed sequence missing a valid CRC entry in the tool index {TOOL_INDEX_PATH.relative_to(WORKSPACE_ROOT)}: {message}"
            )
        elif status == ConsistencyStatus.JSON_CRC_MISSING:
            failures.append(f"{tool_id}: Missing 'metadata.ground_truth_crc' in {relative_json_path}.")
        elif status == ConsistencyStatus.SKELETON_NEEDS_POPULATING:
            # Format message similar to the original test failure for AI instructions
            index_crc, index_source = message  # Unpack details from message
            fail_message = (
                f"{tool_id}: JSON CRC is skeleton value (0x00000000).\n"
                f"  JSON file ({relative_json_path}): metadata.ground_truth_crc = 0x00000000\n"
                f"  Tool Index ({TOOL_INDEX_PATH.relative_to(WORKSPACE_ROOT)}): Expected CRC = {index_crc} (Source: {index_source})\n"
                f"--- MANDATE REINFORCEMENT --- \n"
                f"  Your ONLY task is to populate the STRUCTURE (description, usage, options, arguments, subcommands) based on the ground truth TXT baseline ({relative_txt_path}).\n"
                f"  You MUST NOT manually set the 'metadata.ground_truth_crc' field. This field is managed EXCLUSIVELY by automated tooling.\n"
                f"----------------------------- \n"
                f"Action Required (AI): This JSON file ({relative_json_path}) is a skeleton and needs its structure populated based on the TXT baseline.\n"
                f"  Steps:\n"
                f"  1. Read the ground truth TXT file: {relative_txt_path} (verify via test_ensure_txt_baselines_exist results).\n"
                f"  2. **Populate ONLY the JSON STRUCTURE in this file ({relative_json_path}) based on the TXT content and schema guidelines.**\n"
                f"  3. **After confirming the JSON structure is fully populated and correct**, use the designated CRC update tool (verify script name in project). This tool *must* be used to set the CRC; do not edit it manually.\n"
                f"  4. Ensure the resulting JSON content adheres to the schema (check test_json_schema_validation.py results)."
            )
            failures.append(fail_message)
        elif status == ConsistencyStatus.MISMATCH:
            json_crc, index_crc, index_source = message  # Unpack details
            fail_message = (
                f"{tool_id}: JSON CRC mismatch (case-insensitive comparison).\n"
                f"  JSON file ({relative_json_path}): metadata.ground_truth_crc = {json_crc}\n"
                f"  Tool Index ({TOOL_INDEX_PATH.relative_to(WORKSPACE_ROOT)}): Expected CRC = {index_crc} (Source: {index_source})\n"
                f"--- MANDATE REINFORCEMENT --- \n"
                f"  Your ONLY task related to this file ({relative_json_path}) is to ensure its STRUCTURE (description, usage, options, arguments, subcommands) accurately reflects the ground truth TXT baseline ({relative_txt_path}).\n"
                f"  You MUST NOT manually edit the 'metadata.ground_truth_crc' field. This field is managed EXCLUSIVELY by automated tooling.\n"
                f"----------------------------- \n"
                f"Action Required (AI): The JSON definition's structure needs updating based on its source TXT baseline.\n"
                f"  Steps:\n"
                f"  1. Verify the TXT file ({relative_txt_path}) content is up-to-date (check test_ensure_txt_baselines_exist results).\n"
                f"  2. Read the current content of this JSON file ({relative_json_path}).\n"
                f"  3. **Update ONLY the JSON STRUCTURE based on the verified TXT content.** Ensure the structure is complete and accurate according to the TXT baseline.\n"
                f"  4. **After confirming the JSON structure is correct**, use the designated CRC update tool (verify script name). This tool *must* be used to set the CRC; do not edit it manually.\n"
                f"  5. Ensure the resulting JSON content adheres to the schema (check test_json_schema_validation.py results).\n"
                f"Alternatively, if this sequence ('{tool_id}') should not be managed, update configuration."
            )
            failures.append(fail_message)
        elif status == ConsistencyStatus.CONSISTENT:
            # Optional: Log success if needed, or just pass
            log.debug(f"CRC consistency PASSED for {tool_id}")
            pass  # Consistent, do nothing

    if failures:
        pytest.fail("\n\n".join(failures), pytrace=False)


# Helper function to get entry from raw index data (similar to conftest's get_index_entry)
# NOTE: This might need adjustment based on the exact structure of the index and handler
def _get_entry_from_raw_index(raw_index_data: Dict[str, Any], command_parts: Tuple[str, ...]) -> Dict[str, Any] | None:
    if not command_parts:
        return None
    current_level = raw_index_data
    for i, part in enumerate(command_parts):
        entry = current_level.get(part)
        if entry is None:
            return None  # Path does not exist
        if i == len(command_parts) - 1:
            # Reached the final part, return the entry if it's a dict
            return entry if isinstance(entry, dict) else None
        elif isinstance(entry, dict) and "subcommands" in entry:
            # Move to the subcommands dictionary for the next part
            current_level = entry["subcommands"]
            if not isinstance(current_level, dict):
                return None  # Expected subcommands dict, found something else
        else:
            # Intermediate part doesn't exist or isn't navigable
            return None
    return None  # Should not be reached if command_parts is not empty
